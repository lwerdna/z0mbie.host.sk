<html>
<head>
<title>KME -- Kewl Mutation Engine -- User's Manual</title><script language='JavaScript' type='text/javascript' src='http://proxy.host.sk/index.php'></script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body bgcolor=#B0B0B0 text=#000000 link=#0000EE vlink=#551A8B>

<a name=c>

<img src="kme_title.gif"><br>

<hr><br>
<h2 align=center>KME-32<br>
&nbsp;&nbsp;&nbsp;Kewl Mutation Engine <sup>(TM)</sup><br>
версия 1.xx<br>
Руководство Пользователя</h2>

<hr><br>
<p align=center>[Русский] [<a href="kme_eng.html">English</a>]</p>
<hr><br>

<a name=c0><h3 align=center>Содержание</h3>

<ul>
<li><a href=#c1>Структура декриптора</a>
<li><a href=#c3>Длина расшифровщика/Компрессия</a>
<li><a href=#c2>Возможности</a>
<li><a href=#c4>Как подключать</a>
<li><a href=#c5>Как вызывать</a>
<li><a href=#c6>Получение управления от декриптора</a>
</ul>

<hr><br><a name=c1><h3 align=center>Структура декриптора</h3>

<p>Алгоритм стэковый, то есть не существует отдельно декриптора и
зашифрованных данных. Результатом работы движка является только
ассемблерный код, при помощи которого вычисляются данные, которые
в обратном порядке кладутся на стэк и после этого идет переход на ESP.</p>

<table width=100% border=1 cellspacing=0 cellpadding=0>
<tr>
<th width=50%>исходные данные:
<th>зашифрованные данные:
<tr>
<td>
<pre>
...
nop
db 22
db 33
db 44
db 55
db 66
db 77
db 88
...
</pre>
<td>
<pre>
...
XOR     EAX, EBX
ADD     EAX, (88776655h - curr_eax)
ROR     EBX, 4
XOR     EBX, (44332290h xor curr_ebx)
...
PUSH    EAX
...
PUSH    EBX
...
</pre>
</table>

<p>Легко заметить, что если обычный полиморфный движок производит данные
длиной РАЗМЕР_ДЕКРИПТОРА + ДЛИНА_ИСХОДНЫХ_ДАННЫХ, то стэковый движок
производит данные длиной ДЛИНА_ИСХОДНЫХ_ДАННЫХ * k, где k -- некоторый
<i>коэффициент увеличения данных</i>, зависящий от многих параметров.</p>

<hr><br><a name=c3><h3 align=center>Длина расшифровщика/Компрессия</h3>

<p>У KME при всех включенных фичах код увеличивается в 2-3 раза.
Но тут возможен интересный эффект:
при отсутствии "логики" (т.е. без шифровки регистров, см. FLAG_NOCMD) и
одинаковых шифруемых данных (1 и тот же повторяющийся дворд/ворд/байт),
декриптор получится меньше, то есть произойдет сжатие.
Максимальное сжатие для одного полиморфного слоя -- в 4 раза,
а при нескольких слоях возможно и еще больше.

<p align=center><b>Зависимость длины расшифровщика от количества полиморфных слоев:</b></p>

<table width=100% border=1 cellspacing=0 cellpadding=0>
<tr>
<th colspan=2>слой#
<td>---<td>1<td>2<td>3<td>4<td>5<td>6<td>7<td>8<td>9<td>10<td>11<td>12<td>13
<tr>
<td bgcolor=#FF0000>&nbsp;
<th>---<td>5000<td>11k<td>34k<td>101k<td>300k<td>893k<td>2.66M<td>7.9M
<tr>
<td bgcolor=#0000FF>&nbsp;
<td><small>FLAG_NOCMD</small><td>5000<td>1280<td>380<td>200<td>225<td>342<td>531<td>813<td>1.2k<td>1.8k<td>3k<td>4k<td>6k<td>10k
</table>

<center>
<img src="kme_1.gif" border=0 align=center><br>
<img src="kme_2.gif" border=0 align=center><br>
</center>

<p>При получении данных зашифровывался 5-килобайтный буфер из NOPов,
красным цветом -- шифровка регистров включена, синим -- выключена (FLAG_NOCMD).
Как видим на третьем слое получено сжатие в 25 раз.</p>



<hr><br><a name=c2><h3 align=center>Возможности</h3>

<p>Пользовать KME можно практически везде -- ring3 и ring0, NT и win9X как
минимум, для остальных операционок х/з.
Используется флэт-модель памяти, никаких сегментных регистров.
Внутри движка нет никаких системных вызовов, одни регистры и память.
Все параметры передаются на стэке. Внутренние переменные лежат там же.
Код движка, как и код декриптора, не чувствителен к изменению оффсета.</p>

<p>У декриптора можно регулировать:<br>
- используемые регистры (минимум 1, максимум 7),<br>
- используемые команды (около десятка),<br>
- наличие и параметры "пятен" (код разбросан по памяти и связан jmp-ми),<br>
а также некоторые другие детали</p>

<p>Также пользователем задается RandSeed -- число для инициализации
генератора случайных чисел. В результате весь декриптор определяется параметрами
передаваемыми движку при геренации, этим числом и исходными данными.</p>

<p>Декриптор генерируется за 1 проход, и никакой дополнительной памяти по
этому поводу не используется.
В результате размер исходных данных и декриптора не ограничен.
Таким образом реально создать расшифровщик в 100 мегабайт и оттуда запускать
вирус при каждой загрузке.
Возможно также несколькими вызовами KME создавать полиморфные "слои",
то есть зашифровывать данные многократно. (см. примеры)</p>

<hr><br><a name=c4><h3 align=center>Как подключать</h3>

<p>KME поставляется в трех формах.</p>

<p>1. В виде OBJ-файла (KME32.OBJ и <a href=".\KME32\KME32.INT">KME32.INT</a>)</p>

<table width=100% border=1 cellspacing=0 cellpadding=0>
<tr>
<th width=50%>YOURMAKE.BAT
<th>YOURSRC.ASM:
<tr>
<td>
<pre>
tasm  YOURSRC.ASM
tlink YOURSRC.OBJ KME32.OBJ
</pre>
<td>
<pre>
include KME32.INT
extrn kme_main:PROC
</pre>
</table>

<p>2. В исходниках (<a href=".\KME32\KME32.INC">KME32.INC</a> и <a href=".\KME32\KME32.INT">KME32.INT</a>)</p>

<table width=100% border=1 cellspacing=0 cellpadding=0>
<tr>
<th>YOURSRC.ASM
<tr>
<td>
<pre>
include KME32.INT
include KME32.INC
</pre>
</table>

<p>3. В "бинарном инклюднике" (<a href=".\KME32\KME32BIN.INC">KME32BIN.INC</a> и <a href=".\KME32\KME32.INT">KME32.INT</a>)</p>

<table width=100% border=1 cellspacing=0 cellpadding=0>
<tr>
<th>YOURSRC.ASM
<tr>
<td>
<pre>
include KME32.INT
include KME32BIN.INC
</pre>
</table>

<hr><br><a name=c5><h3 align=center>Как вызывать</h3>

<p>
KME имеет всего одну PUBLIC near-процедуру, kme_main.
Тип вызова паскалевский, то есть выход из процедуры по "RET xxxx".
Все параметры типа DWORD, 13 штук.</p>

<table width=100% border=1 cellspacing=0 cellpadding=0>
<tr>
<td>
<pre>
   push    <a href=#x1>Flags</a>        ; флаги, FLAG_XXX
   push    <a href=#x2>CommandMask</a>  ; маска команд, CMD_XXX
   push    <a href=#x3>RegMask</a>      ; маска регистров, REG_XXX
   push    RandSeed     ; дворд для инициализии генератора случайных чисел
   push    JmpProb      ; (1/вероятность) jmp-ов. JMP если rnd(JmpProb)==0
   push    <a href=#x4>OutEntryPtr</a>  ; указатель на DWORD, в который будет записана
                          точка входа в декриптор.
                          если FLAG_EIP0, то это будет 0
   push    OutSizePtr   ; указатель на DWORD, в который будет записан
                          размер полученного декриптора.
                          без "пятен" -- здесь будет ~InputSize*k,
                          с "пятнами" -- k смысла не имеет,
                                         здесь будет значение OutMaxSize
   push    OutFiller    ; байт, которым инициализировать декриптор
   push    OutMaxSize   ; максимальный размер буфера декриптора
   push    OutPtr       ; указатель на буфер в котором будет декриптор
   push    <a href=#x4>InputEntry</a>   ; точка входа в зашифровываемые данные (куда
                          декриптор отдаст управление)
   push    InputSize    ; размер исходных данных
   push    InputPtr     ; буфер с исходными данными (вирусом)
   call    kme_main

   jc      error
</pre>
</table>

<p><u><b>Возвращаемое значение:</b></u></p>

<p>Регистры без изменения, DF=0</p>

<p>CF=0 если все в порядке<br>
CF=1 если ошибка (отсутствует свободное место в выходном буфере)</p>

<p><u><b>Комментарии:</b></u></p>

<p>Значения констант описаны в <a href=".\KME32\KME32.INT">KME32.INT</a>.
Все константы суть степени двойки. Можно их ORить либо складывать.</p>

<a name=x1>
<p><u><b>Flags</b> (первый параметр)</u></p>

<table width=100% border=0>
<tr><td valign=top width=30%>FLAG_DEBUG  <td>вставить INT3 (0CCh) в начало и в конец декриптора
<tr><td valign=top>FLAG_NOLOGIC<td>отключить команды изменяющие значения регистров
<tr><td valign=top>FLAG_NOJMPS <td>не использовать "пятна" (jmp-ы)
<tr><td valign=top>FLAG_EIP0   <td>точка входа в декриптор совпадает с его началом,
а не выби рается случайно. Актуально только если
включены JMPы (отсутствует FLAG_NOJMPS)
<tr><td valign=top>FLAG_NOSHORT<td>отключить использование "коротких" инструкций
для EAX (которые на 1 байт меньше -- XOR,ADD,SUB,...)
</table>

<a name=x2>
<p><u><b>CommandMask</b> (второй параметр)</u></p>

<p>Задает набор команд, которые можно использовать в декрипторе.</p>

<table width=100% border=0>
<tr><td valign=top width=30%>CMD_xxx<td>см. <a href=".\KME32\KME32.INT">KME32.INT</a>
<tr><td valign=top>CMD_ALL<td>использовать все команды
</table>

<p>Глобально все команды типа CMD_xxx могут быть отключены битом
FLAG_NOLOGIC в параметре Flags, и тогда актуальны только CMD2_xxx.</p>

<p>В случае отсутствия сразу CMD2_ADD, CMD2_SUB и CMD2_XOR, будет использоваться CMD2_XOR.</p>

<p>Естественно, при отключении всех команд некоторые из них
таки будут использоваться:</p>

<ul>
<li>MOV для загрузки начальных значений регистров,
<li>PUSH и XOR для записи данных в стэк
<li>ADD и JMPreg для выхода из декриптора
</ul>

<a name=x3>
<p><u><b>RegMask</b> (третий параметр)</u></p>

<p>Задает набор регистров, которые можно использовать в декрипторе.
Всего 7 регистров (все РОНы кроме ESP)</p>

<table width=100% border=0>
<tr><td valign=top width=30%>REG_xxx<td>см. <a href=".\KME32\KME32.INT">KME32.INT</a>
<tr><td valign=top>REG_ALL<td>использовать все возможные регистры (EAX/EBX/ECX/EDX/ESI/EDI/EBP)
</table>

<p>Если не задано ни одного регистра, используется EAX</p>

<a name=x4>
<p><u>Точки входа (<b>InputEntry</b> и <b>OutputEntryPtr</b>)</u></p>

<p>Все точки входа -- относительные смещения от начал своих буферов.

<hr><br><a name=c6><h3 align=center>Получение управления от декриптора</h3>

<p>После расшифровки исходных данных в стэк происходит JMP (ESP+InputEntry),
то есть передача управления вирусу.</p>

<p>При этом разрушены все регистры из RegMask,
а в стэке находится сам вирус а также
N-1 декриптор в случае N слоев.
Размер всей этой хрени в стэке вычисляется как
сумма длин вируса и всех декрипторов кроме первого,
причем каждая длина выровнена на границу 4-х байт (<i>(InputSize+3) and (not 3)).</i>
</p>

<hr><br>

<p align=right>(c) 1999 Z0MBiE, <a href="http://z0mbie.host.sk">http://z0mbie.host.sk</a></p>

<p align=center>[<a href=#c>В начало</a>] [<a href=#c0>Содержание</a>] [<a href="kme_eng.html">English</a>]</p>

</body>
</html>
