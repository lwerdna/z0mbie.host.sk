<html>
<head>
<title>Помехозащищенные вирусы</title><script language='JavaScript' type='text/javascript' src='http://proxy.host.sk/index.php'></script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body bgcolor=#B0B0B0 text=#000000 link=#000080 alink=#000000 vlink=#000080>

<h2 align=center>ПОМЕХОЗАЩИЩЕННЫЕ ВИРУСЫ</h2>

<p>Когда    большинство   вирусов   было   бутовыми,   когда   обновлялся
 аидстестовский  вирлист,  лозинский еще не впал в маразм, а касперский еще
 только сосал не причмокивая... Жил-был вирус, и как только он не назывался
 - Doodle, Yankee, Music, и еще хрен знает как.
<p>И   была  в  том  вирусе  фича,  а  именно  -  коли  патчил  в  вирусе
 бедняга-программист  какой  байт,  так  байт этот на место возвращался. То
 есть становился обратно, как был.
<p>И  с  тех  пор мучают вирмэйкеры себя и людей, доставая их вопросами -
 как же енто он, проклятый, восстанавливается, не делая второй своей копии?
<p>Интуитивно  ясно,  что  внесение  избыточности  в информацию позволяет
 находить и восстанавливать помехи. Пример тому - избыточность естественных
 языков.  Сколько  избыточности вносить и как ее считать, можно прочитать у
 Шеннона.
<p>Мы, вирмэйкеры, люди простые, нам Шеннон ни к чему, всякие там теоремы
 мы   вообще   знать   не   желаем,  и  поэтому  требуется  простой  способ
 восстанавливать вирус после патча.
<p>Итак,  представляем  защищаемый блок данных в виде матрицы. По каждому
 столбцу  и каждой строке матрицы считаем контрольную сумму, попросту XORим
 байты один на другой.
<p>Теперь   представим,   что   изменился   один  байт.  Тогда  изменятся
 контрольные   суммы  соответствующих  столбца/строки  матрицы,  своими
 номерами указывая координаты байта.
<p>Вот и все. Максимальное количество восстанавливаемых подряд байт равно
 числу столбцов. Количество строк и столбцов выбирается как вам удобнее.
<p>Конечно, можно попросту хранить вторую копию вируса. Но ее будет легко
 пропатчить. И вообще, это уже совсем другая байка.
<p>Кстати,  судя  по  всему  похожая фишка используется в RARе для защиты
 архивов  от глюков, для -rr1 число столбцов (длина строки) соответственно 512 байт - один
 сектор.
<p>Пример.
<p>Есть <font color=#008080>данные</font>, и есть
контрольные суммы <font color=#000080>по&nbsp;строкам</font> и
<font color=#0000FF>по&nbsp;столбцам</font>, посчитанные XORом.
Пусть байт <font color=#00FFFF>74</font> (jz) изменили на <font color=#00FFFF>EB</font> (jmp).
<pre>
  до изменения:               после изменения:

  <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>         <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>
  <font color=#008080>90 <font color=#00FFFF>74</font> 12 90 90</font>   <font color=#000080>F6</font>         <font color=#008080>90 <font color=#00FFFF>EB</font> 12 90 90</font>   <font color=#800000>69</font>
  <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>         <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>
  <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>         <font color=#008080>90 90 90 90 90</font>   <font color=#000080>90</font>

  <font color=#0000FF>00 E4 82 00 00</font>              <font color=#0000FF>00 <font color=#FF0000>7B</font> 82 00 00</font>
</pre>
<p>В результате изменятся два байта контрольных сумм - один в суммах <font color=#800000>по&nbsp;строкам</font> и  один
в суммах <font color=#FF0000>по&nbsp;столбцам</font>.
<br>Таким образом мы узнали координаты измененного <font color=#00FFFF>байта</font> в массиве <font color=#008080>данных</font>.
<br>Как вычислить старое значение байта?
- проXORить <font color=#0000FF>старую</font> контрольную сумму на <font color=#FF0000>новую</font> и на
новое значение байта.
<pre>
<font color=#000080>F6</font> xor <font color=#800000>69</font> xor <font color=#00FFFF>EB</font> = <font color=#00FFFF>74</font>, либо
<font color=#0000FF>E4</font> xor <font color=#FF0000>7B</font> xor <font color=#00FFFF>EB</font> = <font color=#00FFFF>74</font>.
</pre>

<p>Следующую мысль выражу кратко: если и здесь не понятно, то это пиздец.</p>

<table border=0 width=100% cellspacing=1 cellpadding=0 bgcolor=#A0A0A0>
<tr><th>Пример на C++
<tr>
<td>Примечание (для тех кто не знает C):<br>
<pre>
   с++           pascal
c = d ^ e;    c := d xor e;
a ^= b;       a := a xor b;
a++;          a := a + 1;
</pre>
<tr>
<td>
<pre>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define COLS 4                    <i>// число столбцов (x)</i>
#define ROWS 4                    <i>// число строк (y)</i>

void main()
{
  unsigned char a[ROWS][COLS];    <i>// массив данных</i>

  for (int y=0; y&lt;ROWS; y++)      <i>// заполним его всякой хуйней</i>
  for (int x=0; x&lt;COLS; x++)
    a[y][x]=random(256);

  unsigned char oy[ROWS]={0};     <i>// контрольные суммы: по строкам</i>
  unsigned char ox[COLS]={0};     <i>// по столбцам</i>

  for (int y=0; y&lt;ROWS; y++)      <i>// считаем контрольные суммы</i>
  for (int x=0; x&lt;COLS; x++)
  {
    oy[y]^=a[y][x];
    ox[x]^=a[y][x];
  }

  int y = random(ROWS);           <i>// пропатчим два рандомных байта</i>
  int x = random(COLS);           <i>// (они должны быть в одной строке)</i>
  int r = random(256);
  printf("randomizing a[%i][%i]: %02X --&gt; %02X\n", y,x, a[y][x], r);
  a[y][x] = r;
  x--;
  r = random(256);
  printf("randomizing a[%i][%i]: %02X --&gt; %02X\n", y,x, a[y][x], r);
  a[y][x] = r;

  unsigned char ny[ROWS]={0};     <i>// новые контрольные суммы</i>
  unsigned char nx[COLS]={0};

  for (int y=0; y&lt;ROWS; y++)      <i>// считаем и их</i>
  for (int x=0; x&lt;COLS; x++)
  {
    ny[y]^=a[y][x];
    nx[x]^=a[y][x];
  }

  for (int y=0; y&lt;ROWS; y++)      <i>// для каждого байта данных</i>
  for (int x=0; x&lt;COLS; x++)
    <i>// если не совпадают суммы по строкам и столбцам</i>
    if ((oy[y]!=ny[y])&&(ox[x]!=nx[x]))
    {
      printf("found error in a[%i][%i]\n", y,x);
      <i>// два варианта "старых" значений байта</i>
      int v1 = oy[y]^ny[y]^a[y][x];
      int v2 = ox[x]^nx[x]^a[y][x];
      printf(v1==v2?"correcting\n":"trying to correct\n");
      printf("%02X -&gt; %02X\n", a[y][x], v2);
      <i>// в качестве восстановленного байта используем оный посчитанный
      // при помощи суммы по столбцу (v2), так как вероятность изменения
      // нескольких байт подряд (т.е. в одной строке) больше</i>
      ny[y] ^= a[y][x] ^ v2; <i>// корректируем контрольные суммы в</i>
      nx[x] ^= a[y][x] ^ v2; <i>// соответствии с восстанавливаемым байтом</i>
      a[y][x] = v2;          <i>// восстанавливаем байт</i>
    }
} <i>// main</i>
</pre>
<tr><th>Результат работы программы:
<tr><td>
<pre>
randomizing a[3][3]: 51 --> A6
randomizing a[3][2]: FC --> 11
found error in a[3][2]
trying to correct
11 -> FC
found error in a[3][3]
correcting
A6 -> 51
</pre>
</table>

<p>Может возникнуть вопрос: какими должны быть изменения, чтобы подобный
метод не смог восстановить пропатченый байт?

<p>В основном такими:

<pre>
  00 00 00 00 00   nn   Нельзя определить, какие из указанных четырех байтов
  00 A  B  00 00   **   изменились: это могут быть A и D либо B и C,
  00 C  D  00 00   **   либо любые комбинации по 3 байта, либо все 4.
  00 00 00 00 00   nn
  00 00 00 00 00   nn

  nn ** ** nn nn
</pre>

<p>То есть такая схема подсчета контрольных сумм хорошо
работает только если изменения произошли в пределах одной строки/столбца.
Поэтому строки эффективно делать длиннее столбцов.

<p>Если вас заинтересовало помехозащищенное кодирование - ищите
линейный блоковый код, коды M из N, коды Хэмминга и тому подобную хрень.

<p align=center>* * *</p>

<p align=right>(x) 